import {
  PlayerAction
} from "./chunk-HM7ITFY7.mjs";
import {
  CardRank,
  CardSuit,
  cardToEmojiString,
  cardToString
} from "./chunk-7HMSGKED.mjs";
import {
  PokerEngineEvents_default
} from "./chunk-IE3D5VJM.mjs";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-HEBXNMVQ.mjs";

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    "use strict";
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/poker-evaluator-ts/lib/constants/card-ranks.const.js
var require_card_ranks_const = __commonJS({
  "node_modules/poker-evaluator-ts/lib/constants/card-ranks.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CARD_RANKS = [
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "t",
      "j",
      "q",
      "k",
      "a"
    ];
  }
});

// node_modules/poker-evaluator-ts/lib/constants/deck.const.js
var require_deck_const = __commonJS({
  "node_modules/poker-evaluator-ts/lib/constants/deck.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DECK = {
      "2c": 1,
      "2d": 2,
      "2h": 3,
      "2s": 4,
      "3c": 5,
      "3d": 6,
      "3h": 7,
      "3s": 8,
      "4c": 9,
      "4d": 10,
      "4h": 11,
      "4s": 12,
      "5c": 13,
      "5d": 14,
      "5h": 15,
      "5s": 16,
      "6c": 17,
      "6d": 18,
      "6h": 19,
      "6s": 20,
      "7c": 21,
      "7d": 22,
      "7h": 23,
      "7s": 24,
      "8c": 25,
      "8d": 26,
      "8h": 27,
      "8s": 28,
      "9c": 29,
      "9d": 30,
      "9h": 31,
      "9s": 32,
      "tc": 33,
      "td": 34,
      "th": 35,
      "ts": 36,
      "jc": 37,
      "jd": 38,
      "jh": 39,
      "js": 40,
      "qc": 41,
      "qd": 42,
      "qh": 43,
      "qs": 44,
      "kc": 45,
      "kd": 46,
      "kh": 47,
      "ks": 48,
      "ac": 49,
      "ad": 50,
      "ah": 51,
      "as": 52
    };
  }
});

// node_modules/poker-evaluator-ts/lib/constants/hand-types.const.js
var require_hand_types_const = __commonJS({
  "node_modules/poker-evaluator-ts/lib/constants/hand-types.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HAND_TYPES = [
      "invalid hand",
      "high card",
      "one pair",
      "two pairs",
      "three of a kind",
      "straight",
      "flush",
      "full house",
      "four of a kind",
      "straight flush"
    ];
  }
});

// node_modules/poker-evaluator-ts/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/poker-evaluator-ts/lib/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_card_ranks_const(), exports);
    tslib_1.__exportStar(require_deck_const(), exports);
    tslib_1.__exportStar(require_hand_types_const(), exports);
  }
});

// node_modules/poker-evaluator-ts/lib/three-card-converter.js
var require_three_card_converter = __commonJS({
  "node_modules/poker-evaluator-ts/lib/three-card-converter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var ThreeCardConverter = (
      /** @class */
      function() {
        function ThreeCardConverter2() {
        }
        ThreeCardConverter2.fillHand = function(cards) {
          cards = tslib_1.__spreadArrays(cards);
          var cardsUsed = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          cards.forEach(function(card) {
            var index = Math.floor((constants_1.DECK[card.toLowerCase()] - 1) / 4);
            cardsUsed[index] = 1;
          });
          var toFill = 2;
          for (var i = 0; i < cardsUsed.length - 1; i++) {
            if (toFill === 0)
              break;
            if (cardsUsed[i] === 0 && !this.makesStraight(cardsUsed, i)) {
              cardsUsed[i] = 2;
              toFill--;
            }
          }
          var suit = ["s", "d"];
          cardsUsed.forEach(function(cardUsedValue, i2) {
            if (cardUsedValue === 2) {
              var card = constants_1.CARD_RANKS[i2] + suit[0];
              suit.splice(0, 1);
              cards.push(card);
            }
          });
          return cards;
        };
        ThreeCardConverter2.makesStraight = function(cardsUsed, rank) {
          var newCards = [cardsUsed[cardsUsed.length - 1]].concat(cardsUsed);
          newCards[rank + 1] = 2;
          return 5 === newCards.reduce(function(prev, next) {
            if (prev === 5) {
              return 5;
            } else {
              return next ? prev + 1 : 0;
            }
          });
        };
        return ThreeCardConverter2;
      }()
    );
    exports.default = ThreeCardConverter;
  }
});

// node_modules/poker-evaluator-ts/lib/poker-evaluator.js
var require_poker_evaluator = __commonJS({
  "node_modules/poker-evaluator-ts/lib/poker-evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fs = tslib_1.__importStar(__require("fs"));
    var path = tslib_1.__importStar(__require("path"));
    var constants_1 = require_constants();
    var three_card_converter_1 = tslib_1.__importDefault(require_three_card_converter());
    var RANKS_DATA = fs.readFileSync(path.join(__dirname, "../data/HandRanks.dat"));
    function evalHand2(cards) {
      if (!RANKS_DATA) {
        throw new Error("HandRanks.dat not loaded.");
      }
      if (cards.length !== 7 && cards.length !== 6 && cards.length !== 5 && cards.length !== 3) {
        throw new Error("Hand must be 3, 5, 6, or 7 cards, but " + cards.length + " cards were provided");
      }
      if (cardsAreValidStrings(cards)) {
        var stringCards = cards;
        if (stringCards.length === 3) {
          stringCards = three_card_converter_1.default.fillHand(stringCards);
        }
        return evaluate(convertCardsToNumbers(stringCards));
      } else if (cardsAreValidNumbers(cards)) {
        if (cards.length === 3) {
          throw new Error('Please supply 3 card hands as string[] of "cards" only.');
        }
        return evaluate(cards);
      } else {
        throw new Error(`
      Please supply input as a valid string[] | number[] of "cards".
      See src/constants/deck.const.ts for the deck's values
    `);
      }
    }
    exports.evalHand = evalHand2;
    function evalCard(card) {
      return RANKS_DATA.readUInt32LE(card * 4);
    }
    function convertCardsToNumbers(cards) {
      return cards.map(function(card) {
        return constants_1.DECK[card.toLowerCase()];
      });
    }
    function cardsAreValidStrings(cards) {
      return cards.every(function(card) {
        return typeof card === "string" && Object.keys(constants_1.DECK).includes(card.toLowerCase());
      });
    }
    function cardsAreValidNumbers(cards) {
      return cards.every(function(card) {
        return typeof card === "number" && Object.values(constants_1.DECK).includes(card);
      });
    }
    function evaluate(cardValues) {
      var p = 53;
      cardValues.forEach(function(cardValue) {
        return p = evalCard(p + cardValue);
      });
      if (cardValues.length === 5 || cardValues.length === 6) {
        p = evalCard(p);
      }
      return {
        handType: p >> 12,
        handRank: p & 4095,
        value: p,
        handName: constants_1.HAND_TYPES[p >> 12]
      };
    }
  }
});

// src/PlayerTurnTimeOut.ts
import { setTimeout } from "timers";

// src/Table.ts
var import_poker_evaluator_ts = __toESM(require_poker_evaluator());
import { clearTimeout } from "timers";
var GameState = /* @__PURE__ */ ((GameState2) => {
  GameState2[GameState2["WaitingForPlayers"] = 0] = "WaitingForPlayers";
  GameState2[GameState2["PreFlop"] = 1] = "PreFlop";
  GameState2[GameState2["Flop"] = 2] = "Flop";
  GameState2[GameState2["Turn"] = 3] = "Turn";
  GameState2[GameState2["River"] = 4] = "River";
  GameState2[GameState2["Showdown"] = 5] = "Showdown";
  GameState2[GameState2["Ended"] = 6] = "Ended";
  return GameState2;
})(GameState || {});
var GAME_EVENTS = {
  PLAYER_TURN: "PLAYER_TURN",
  PLAYER_ACTION: "PLATER_ACTION",
  PLAYER_TURN_EXPIRED: "PLAYER_TURN_EXPIRED",
  GAME_STATE_CHANGED: "GAME_STATE_CHANGED",
  GAME_STARTED: "GAME_STARTED",
  GAME_ENDED: "GAME_ENDED",
  PLAYER_JOINED: "PLAYER_JOINED",
  PLAYER_LEFT: "PLAYER_LEFT",
  GAME_ACTION_PERFORMED: "GAME_ACTION_PERFORMED",
  GAME_ACTION_COMPLETED: "GAME_ACTION_COMPLETED",
  GAME_ACTION_CANCELLED: "GAME_ACTION_CANCELLED",
  SHOWDOWN: "SHOWDOWN"
};
var Table = class {
  constructor(options = {}) {
    this.deck = [];
    this.players = [];
    this.pot = 0;
    this.gameState = 0 /* WaitingForPlayers */;
    this.communityCards = [];
    this.currentPlayerIndex = 0;
    this.currentDealerIndex = 0;
    this.currentBigBlindIndex = 0;
    this.currentSmallBlindIndex = 1;
    this.minimumBet = 5;
    // Apuesta mínima para cada ronda
    this.currentBet = 0;
    // Apuesta actual en la ronda
    this.smallBlind = 5;
    this.bigBlind = 10;
    this.playerTurnTimeLimit = 5;
    this.history = [];
    var _a, _b, _c, _d;
    this.events = new PokerEngineEvents_default();
    this.playerTurnTimeout = new PlayerTurnTimeOut_default(this);
    this.maxPlayers = options.maxPlayers !== void 0 ? options.maxPlayers : 10;
    this.players = (_a = options.players) != null ? _a : [];
    this.currentDealerIndex = (_b = options.currentDealerIndex) != null ? _b : 0;
    this.minimumBet = (_c = options.minimunbet) != null ? _c : 5;
    this.playerTurnTimeLimit = (_d = options.playerTurnTimeLimit) != null ? _d : 15;
    this.initializeDeck();
  }
  // Inicializa el mazo con 52 cartas
  initializeDeck() {
    this.deck = [];
    for (let suit in CardSuit) {
      for (let rank in CardRank) {
        this.deck.push({
          suit: CardSuit[suit],
          rank: CardRank[rank]
        });
      }
    }
    this.shuffleDeck();
  }
  /**
   * Shuffles the deck of cards using the Fisher-Yates shuffle algorithm
   * @see https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
   * @returns {void}
   */
  shuffleDeck() {
    for (let i = this.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
    }
  }
  /**
   * Add player to table. set seat and assign seat number secuentially
   * if not seat number is specified
   * @param player {Player} The player to add
   * @param seatNumber? {number} Optional seat number
   * @returns {boolean} True if the player was added, false otherwise
   */
  seatPlayer(player, seatNumber) {
    if (this.players.length >= this.maxPlayers) {
      throw new Error("No more players allowed for this game");
    }
    const isSeatTaken = this.players.some((p) => p.seatNumber === seatNumber);
    if (isSeatTaken) {
      throw new Error(`El asiento ${seatNumber} ya esta ocupado`);
    }
    if (this.players.length < this.maxPlayers) {
      player.seatNumber = seatNumber != null ? seatNumber : this.players.length + 1;
      this.players.push(player);
      return true;
    }
    return false;
  }
  // Inicia el juego
  startGame() {
    if (this.players.length < 2) {
      throw new Error("No hay suficientes jugadores para iniciar el juego.");
    }
    this.gameState = 1 /* PreFlop */;
    this.dealInitialCards();
    this.currentDealerIndex = 0;
    this.currentSmallBlindIndex = this.players.length === 2 ? 0 : 1;
    this.currentBigBlindIndex = this.currentSmallBlindIndex + 1;
    this.currentPlayerIndex = this.currentSmallBlindIndex;
    this.events.emit(GAME_EVENTS.PLAYER_TURN, {
      playerId: this.players[this.currentPlayerIndex].id
    });
    this.events.on(GAME_EVENTS.PLAYER_TURN_EXPIRED, (data) => {
      if (this.gameState === 6 /* Ended */) return;
      let autoPlay = PlayerAction.Check;
      if (this.gameState === 5 /* Showdown */) {
        autoPlay = PlayerAction.Hide;
      }
      const player = this.players[this.currentPlayerIndex];
      if (this.gameState === 1 /* PreFlop */ && player.betAmount === 0 && player.id === this.players[this.currentSmallBlindIndex].id) {
        console.log(
          `Time is up for player ${player.name} turn! Automatic play for player is ${autoPlay} game state: ${this.gameState}`
        );
        this.playerAction(player.id, PlayerAction.Bet, this.minimumBet);
        return;
      }
      if (this.gameState === 1 /* PreFlop */ && player.betAmount === 0 && player.id === this.players[this.currentBigBlindIndex].id) {
        console.log(
          `Time is up for player ${player.name} turn! Automatic play for player is ${autoPlay} game state: ${this.gameState}`
        );
        this.playerAction(player.id, PlayerAction.Bet, this.minimumBet * 2);
        return;
      }
      if (player.betAmount < this.currentBet) {
        autoPlay = PlayerAction.Fold;
      }
      console.log(
        `Time is up for player ${player.name} turn! Automatic play for player is ${autoPlay} game state: ${this.gameState}`
      );
      this.playerAction(player.id, autoPlay);
    });
  }
  // Reparte dos cartas a cada jugador
  dealInitialCards() {
    for (let player of this.players) {
      player.hand = [this.deck.pop(), this.deck.pop()];
    }
  }
  // Procede a la siguiente ronda (Flop, Turn, River, Showdown)
  proceedToNextRound() {
    switch (this.gameState) {
      case 1 /* PreFlop */:
        console.debug(`Starting Flop. current bet: ${this.currentBet}`);
        this.gameState = 2 /* Flop */;
        this.dealCommunityCards(3);
        this.history.push({
          timestamp: /* @__PURE__ */ new Date(),
          type: "GameStateChange",
          communityCards: this.communityCards,
          details: {
            newState: "flop"
          },
          players: this.players.map((p) => {
            return {
              playerId: p.id,
              chips: p.chips,
              cards: p.hand,
              isFolded: p.isFolded,
              betAmount: p.betAmount
            };
          })
        });
        break;
      case 2 /* Flop */:
        console.debug(`Starting Turn. current bet: ${this.currentBet}`);
        this.gameState = 3 /* Turn */;
        this.dealCommunityCards(1);
        this.history.push({
          timestamp: /* @__PURE__ */ new Date(),
          type: "GameStateChange",
          communityCards: this.communityCards,
          details: {
            newState: "turn"
          },
          players: this.players.map((p) => {
            return {
              playerId: p.id,
              chips: p.chips,
              cards: p.hand,
              isFolded: p.isFolded,
              betAmount: p.betAmount
            };
          })
        });
        break;
      case 3 /* Turn */:
        console.debug(`Starting River. current bet: ${this.currentBet}`);
        this.gameState = 4 /* River */;
        this.dealCommunityCards(1);
        this.history.push({
          timestamp: /* @__PURE__ */ new Date(),
          type: "GameStateChange",
          communityCards: this.communityCards,
          details: {
            newState: "river"
          },
          players: this.players.map((p) => {
            return {
              playerId: p.id,
              chips: p.chips,
              cards: p.hand,
              isFolded: p.isFolded,
              betAmount: p.betAmount
            };
          })
        });
        break;
      case 4 /* River */:
        console.debug(`Starting Showdown. current bet: ${this.currentBet}`);
        this.gameState = 5 /* Showdown */;
        this.events.emit(GAME_EVENTS.GAME_STATE_CHANGED, {
          details: {
            newState: 5 /* Showdown */
          }
        });
        this.history.push({
          timestamp: /* @__PURE__ */ new Date(),
          type: "GameStateChange",
          communityCards: this.communityCards,
          details: {
            newState: "showdown"
          },
          players: this.players.map((p) => {
            return {
              playerId: p.id,
              chips: p.chips,
              cards: p.hand,
              isFolded: p.isFolded,
              betAmount: p.betAmount
            };
          })
        });
        break;
      case 5 /* Showdown */:
        console.debug(`Game Ended`);
        this.determineWinners();
        this.gameState = 6 /* Ended */;
        this.history.push({
          timestamp: /* @__PURE__ */ new Date(),
          type: "GameStateChange",
          communityCards: this.communityCards,
          details: {
            newState: "ended"
          },
          players: this.players.map((p) => {
            return {
              playerId: p.id,
              chips: p.chips,
              cards: p.hand,
              isFolded: p.isFolded,
              betAmount: p.betAmount
            };
          })
        });
        break;
      case 6 /* Ended */:
        clearTimeout(this.playerTurnTimeout);
        break;
      default:
        throw new Error("Invalid Game State");
    }
  }
  // Reparte cartas comunitarias
  dealCommunityCards(count) {
    for (let i = 0; i < count; i++) {
      this.communityCards.push(this.deck.pop());
    }
  }
  determineWinners() {
    console.debug("Determining winners");
    let winners = [];
    const activePlayers = this.players.filter((player) => !player.isFolded);
    const communityCards = this.communityCards.map(
      (card) => cardToString(card)
    );
    let highestValue = -Infinity;
    if (activePlayers.length === 1) {
      winners = activePlayers;
    } else {
      activePlayers.forEach((player) => {
        const playerHand = player.hand.map((card) => cardToString(card));
        const handEval = (0, import_poker_evaluator_ts.evalHand)([...playerHand, ...communityCards]);
        const handValue = handEval.value;
        if (handValue > highestValue) {
          highestValue = handValue;
          winners = [
            {
              player,
              rank: handEval.handRank,
              type: handEval.handType,
              value: handEval.value,
              name: handEval.handName
            }
          ];
        } else if (handValue === highestValue) {
          winners.push({
            player,
            rank: handEval.handRank,
            type: handEval.handType,
            value: handEval.value,
            name: handEval.handName
          });
        }
      });
    }
    console.log(
      "Comunity cards: ",
      this.communityCards.map((card) => cardToEmojiString(card)).join(" ")
    );
    console.log("Hand in showdown: ");
    activePlayers.map(
      (player) => console.log(
        "Name: " + player.name + " Hand: " + player.hand.map((card) => cardToEmojiString(card)).join(" ")
      )
    );
    if (winners.length > 1) {
      const dividedPot = this.pot / winners.length;
      winners.forEach((winner) => winner.chips += dividedPot);
    } else {
      winners[0].player.chips += this.pot;
    }
    this.pot = 0;
    console.log("Winners: ");
    winners.map(
      (winner) => console.log(
        "Name: " + winner.player.name + " Hand: " + winner.player.hand.map((card) => cardToEmojiString(card)).join(" ") + " Winning Hand: " + winner.name + " Value: " + winner.value + " Chips: " + winner.player.chips
      )
    );
    this.events.emit(GAME_EVENTS.GAME_ENDED, {
      winners,
      comunityCards: this.communityCards
      // add more info like the hand name
    });
    return { winners, comunityCards: this.communityCards };
  }
  // Inicia una ronda de apuestas
  startBettingRound() {
    this.minimumBet = this.getBigBlind();
    this.currentBet = 0;
    this.players.forEach((player) => player.betAmount = 0);
    this.currentPlayerIndex = this.getNextPlayerIndex(this.currentPlayerIndex);
    this.processPlayerAction();
  }
  processPlayerAction() {
    const player = this.players[this.currentPlayerIndex];
    if (player.isFolded || player.chips === 0) {
      this.nextPlayer();
      return;
    }
    this.events.emit(GAME_EVENTS.PLAYER_TURN, {
      playerId: this.players[this.currentPlayerIndex].id
    });
  }
  /**
   * Process a player action.
   * @param {string} playerId the id of the player performing the action
   * @param {PlayerAction} action the action to perform
   * @param {number?} amount the amount to bet or raise
   * @throws {Error} if the player is not found
   * @throws {Error} if the player is not in turn
   * @throws {Error} if the amount is not specified for Bet or Raise actions
   * @throws {Error} if the player is trying to bet or raise with not enough chips
   * @throws {Error} if the player is trying to bet or raise with an invalid amount
   * @throws {Error} if the player is trying to show cards in a state that is not Showdown
   * @throws {Error} if the player is trying to hide cards in a state that is not Showdown
   */
  playerAction(playerId, action, amount) {
    const player = this.players.find((p) => p.id === playerId);
    if (!player) {
      throw new Error("Jugador no encontrado.");
    }
    const currentPlayerId = this.players[this.currentPlayerIndex].id;
    if (playerId != currentPlayerId) {
      throw new Error(
        `It's not player ${playerId} turn to play. Is player id: ${currentPlayerId} turn`
      );
    }
    this.events.on(
      GAME_EVENTS.PLAYER_ACTION,
      (data) => {
        clearTimeout(this.playerTurnTimeout);
        console.log(`The player ${playerId} make: ${data.action}`);
        this.history.push({
          timestamp: /* @__PURE__ */ new Date(),
          type: "PlayerAction",
          communityCards: this.communityCards,
          details: {
            action: data.action,
            playerId: data.playerId,
            amount: data == null ? void 0 : data.amount
          },
          players: this.players.map((p) => {
            return {
              playerId: p.id,
              chips: p.chips,
              cards: p.hand,
              isFolded: p.isFolded,
              betAmount: p.betAmount
            };
          })
        });
      }
    );
    switch (action) {
      case PlayerAction.Fold:
        player.isFolded = true;
        console.debug(`Player ${player.name} Folded. Bet: ${player.betAmount}`);
        this.events.emit(GAME_EVENTS.PLAYER_ACTION, { playerId, action });
        break;
      case PlayerAction.Call:
        const callAmount = this.currentBet - player.betAmount;
        if (player.chips < callAmount)
          throw new Error(
            `Player has no enough chips (${player.chips} to Call ${callAmount} and match ${this.currentBet})`
          );
        player.chips -= callAmount;
        player.betAmount = this.currentBet;
        this.pot += callAmount;
        this.events.emit(GAME_EVENTS.PLAYER_ACTION, { playerId, action });
        break;
      case PlayerAction.Raise:
        if (amount !== void 0) {
          const raiseAmount = amount - player.betAmount;
          if (player.chips < raiseAmount)
            throw new Error(
              `No enough chips (${player.chips}) to raise ${raiseAmount}`
            );
          player.chips -= raiseAmount;
          player.betAmount += raiseAmount;
          this.pot += raiseAmount;
          this.currentBet = this.currentBet + raiseAmount;
          console.debug(
            `Player ${player.name} raised ${raiseAmount} to ${player.betAmount}.  Pot: ${this.pot}`
          );
        } else {
          throw new Error("Must specify amount to Raise");
        }
        this.events.emit(GAME_EVENTS.PLAYER_ACTION, { playerId, action });
        break;
      case PlayerAction.Bet:
        if (this.gameState != 1 /* PreFlop */) {
          throw new Error("Bet action only allowed in PreFlop");
        }
        if (amount === void 0)
          throw new Error("Amount must be specified for Bet action");
        if (amount < this.minimumBet) {
          throw new Error(
            `This min amount for this hand is ${this.minimumBet}`
          );
        }
        if (player.id === this.players[this.currentSmallBlindIndex].id && amount < this.smallBlind) {
          throw new Error(
            `Small Blind must bet at least ${this.smallBlind} amount`
          );
        }
        if (player.id === this.players[this.currentBigBlindIndex].id && amount < this.bigBlind) {
          throw new Error(
            `Big Blind must bet at least ${this.bigBlind} amount`
          );
        }
        if (player.id === this.players[this.currentBigBlindIndex].id && amount < this.currentBet) {
          throw new Error(
            `Big Blind must bet at least ${this.bigBlind} amount`
          );
        }
        player.chips -= amount;
        player.betAmount = amount;
        this.pot += amount;
        this.currentBet = amount;
        console.debug(`Player ${player.name} Bet ${amount}. Pot: ${this.pot}`);
        this.events.emit(GAME_EVENTS.PLAYER_ACTION, {
          playerId,
          action,
          amount
        });
        break;
      case PlayerAction.Check:
        console.debug(`Player ${player.name} Checked. Pot ${this.pot}`);
        this.events.emit(GAME_EVENTS.PLAYER_ACTION, { playerId, action });
        break;
      case PlayerAction.Hide:
        if (this.gameState != 5 /* Showdown */)
          throw "Cant show cards only in showdown";
        player.showCards = false;
        break;
      case PlayerAction.Show:
        if (this.gameState != 5 /* Showdown */)
          throw new Error("Cant show cards only in showdown");
        player.showCards = true;
        break;
      default:
        throw new Error(`Invalid player action, ${JSON.stringify(action)}`);
    }
    const activePlayers = this.players.filter((p) => !p.isFolded);
    if (activePlayers.length === 1) {
      console.debug(
        "Only one player left with bet. Game state changed showdown"
      );
      this.gameState = 5 /* Showdown */;
    }
    if (this.isBettingRoundOver()) {
      this.proceedToNextRound();
    }
    this.nextPlayer();
  }
  /**
   * Checks if the betting round is over.
   *
   * The betting round is considered over if all players have either folded
   * or matched the current bet amount.
   *
   * @returns {boolean} True if the betting round is over, otherwise false.
   */
  isBettingRoundOver() {
    return this.players.every(
      (player) => player.isFolded || player.betAmount === this.currentBet
    );
  }
  nextPlayer() {
    this.currentPlayerIndex = this.getNextPlayerIndex(this.currentPlayerIndex);
    this.processPlayerAction();
  }
  getNextPlayerIndex(currentIndex) {
    let index = (currentIndex + 1) % this.players.length;
    while (this.players[index].isFolded && index !== currentIndex) {
      index = (index + 1) % this.players.length;
    }
    return index;
  }
  /**
   * Gets the current big blind value.
   *
   * @returns {number} The current big blind value.
   */
  getBigBlind() {
    return this.bigBlind;
  }
  getSmallBlind() {
    return this.smallBlind;
  }
  getMaxBet() {
    return Math.max(...this.players.map((p) => p.betAmount));
  }
  resetTable() {
    this.communityCards = [];
    this.players.forEach((player) => {
      player.hand = [];
      player.isFolded = false;
      player.betAmount = 0;
    });
    this.initializeDeck();
    this.gameState = 1 /* PreFlop */;
  }
  /**
   * Returns the hand history for the current hand.
   *
   * @returns {GameLogEntry[]} An array of GameLogEntry objects representing
   * the actions and events that occurred during the current hand.
   */
  getHandHistory() {
    return this.history;
  }
  handlePlayerTurnTimeout(playerId) {
    console.log(`Player ${playerId} timeout event!`);
  }
};

// src/PlayerTurnTimeOut.ts
var PlayerTurnTimeout = class {
  constructor(table) {
    this.table = table;
    this.table.events.on(GAME_EVENTS.PLAYER_TURN, this.startTimer.bind(this));
  }
  startTimer(data) {
    if (this.table.gameState == 6 /* Ended */) return;
    console.log(
      `Waiting ${this.table.playerTurnTimeLimit} sec for player ${data.playerId} turn`
    );
    const timeout = 15 * 1e3;
    this.table.playerTurnTimeout = setTimeout(() => {
      this.table.events.emit(GAME_EVENTS.PLAYER_TURN_EXPIRED, data);
    }, timeout);
  }
};
var PlayerTurnTimeOut_default = PlayerTurnTimeout;

export {
  PlayerTurnTimeOut_default,
  GameState,
  GAME_EVENTS,
  Table
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
