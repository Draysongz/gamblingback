import Card from './Card.js';
import Player, { PlayerAction } from './Player.js';
import { GameLogEntry } from './GameLogEntry.js';
import PokerEngineEvents from './PokerEngineEvents.js';
import 'events';

declare enum GameState {
    WaitingForPlayers = 0,
    PreFlop = 1,
    Flop = 2,
    Turn = 3,
    River = 4,
    Showdown = 5,
    Ended = 6
}
declare const GAME_EVENTS: {
    PLAYER_TURN: string;
    PLAYER_ACTION: string;
    PLAYER_TURN_EXPIRED: string;
    GAME_STATE_CHANGED: string;
    GAME_STARTED: string;
    GAME_ENDED: string;
    PLAYER_JOINED: string;
    PLAYER_LEFT: string;
    GAME_ACTION_PERFORMED: string;
    GAME_ACTION_COMPLETED: string;
    GAME_ACTION_CANCELLED: string;
    SHOWDOWN: string;
};
declare class Table {
    events: PokerEngineEvents;
    private deck;
    players: Player[];
    pot: number;
    gameState: GameState;
    communityCards: Card[];
    private currentPlayerIndex;
    private currentDealerIndex;
    private currentBigBlindIndex;
    private currentSmallBlindIndex;
    minimumBet: number;
    currentBet: number;
    smallBlind: number;
    bigBlind: number;
    playerTurnTimeLimit: number;
    history: GameLogEntry[];
    playerTurnTimeout: any;
    maxPlayers: number;
    constructor(options?: {
        maxPlayers?: number;
        players?: Player[];
        currentDealerIndex?: number;
        minimunbet?: number;
        playerTurnTimeLimit?: number;
    });
    initializeDeck(): void;
    /**
     * Shuffles the deck of cards using the Fisher-Yates shuffle algorithm
     * @see https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     * @returns {void}
     */
    private shuffleDeck;
    /**
     * Add player to table. set seat and assign seat number secuentially
     * if not seat number is specified
     * @param player {Player} The player to add
     * @param seatNumber? {number} Optional seat number
     * @returns {boolean} True if the player was added, false otherwise
     */
    seatPlayer(player: Player, seatNumber?: number): boolean;
    startGame(): void;
    private dealInitialCards;
    proceedToNextRound(): void;
    private dealCommunityCards;
    private determineWinners;
    startBettingRound(): void;
    processPlayerAction(): void;
    /**
     * Process a player action.
     * @param {string} playerId the id of the player performing the action
     * @param {PlayerAction} action the action to perform
     * @param {number?} amount the amount to bet or raise
     * @throws {Error} if the player is not found
     * @throws {Error} if the player is not in turn
     * @throws {Error} if the amount is not specified for Bet or Raise actions
     * @throws {Error} if the player is trying to bet or raise with not enough chips
     * @throws {Error} if the player is trying to bet or raise with an invalid amount
     * @throws {Error} if the player is trying to show cards in a state that is not Showdown
     * @throws {Error} if the player is trying to hide cards in a state that is not Showdown
     */
    playerAction(playerId: string, action: PlayerAction, amount?: number): void;
    /**
     * Checks if the betting round is over.
     *
     * The betting round is considered over if all players have either folded
     * or matched the current bet amount.
     *
     * @returns {boolean} True if the betting round is over, otherwise false.
     */
    private isBettingRoundOver;
    private nextPlayer;
    private getNextPlayerIndex;
    /**
     * Gets the current big blind value.
     *
     * @returns {number} The current big blind value.
     */
    private getBigBlind;
    private getSmallBlind;
    private getMaxBet;
    resetTable(): void;
    /**
     * Returns the hand history for the current hand.
     *
     * @returns {GameLogEntry[]} An array of GameLogEntry objects representing
     * the actions and events that occurred during the current hand.
     */
    getHandHistory(): GameLogEntry[];
    handlePlayerTurnTimeout(playerId: string): void;
}

export { GAME_EVENTS, GameState, Table as default };
